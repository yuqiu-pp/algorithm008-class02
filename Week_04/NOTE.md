学习笔记

1.DFS和BFS
DFS关键找到重复子问题，然后用递归模板；
BFS借助Queue存放下一层的全部子节点，这样逐层遍历；

[102]二叉树的层序遍历
BFS实现起来很顺畅；

DFS的思想也可以实现，不够每个分支下探时，需要将每个节点放入对应的层次中。
为解决这个问题就要引入额外的结构来存储层次信息，两种处理方式：
1）HashMap<level, List>
2）利用下探的level，直接将结果写入结果集中对应的List中；

[126]单词接龙 II
最开始自己的思路是DFS，每次替换一个字符，如果是合法单词，再次递归下探，直到终止条件满足。
终止条件：找到endWord，或者curr的长度大于wordList。
wordList数据量少时可以得到正确结果，大时就会超时。大概跟踪了一下，主要是因为有单词会在
不同是路径中重复出现，而题目要找的是最短路径，所以数据量大时这个环节会浪费大量时间，甚至
内存溢出。

看了题解，明白了用BFS更合理，因为求的是最短路径。
代码主流程与代码模板基本相同，只是需要处理好避免同一个单词在不同路径重复出现的问题。
关键是理解：一个单词在一个路径中出现后，其它路径中如果再出现这个单词，这个新的路径一定更长。
处理的方式有两种：
1) isVisited[]标识访问过的单词，新的路径遇到后，说明肯定不是解；
2) 访问过的单词直接在wordList中删除；
这里要注意的一点是：当一层全部处理完后，才能做标识或删除操作。

[200]岛屿数量
最先想到的还是DFS，把当前点的向下和向右遍历，直到无路可走。
但是这样想忽略的向上和向左的遍历方向，被题中的“每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成”
的解释给限制了想象力。还是没把题意分析清楚，所以漏掉了两个方向。
还有就是自己没能分析出，什么时候应该将记录岛屿数量的res++，挺遗憾。

BFS思路：是连续1的节点可以继续下探，可以把这个看做是子节点的，这样用BFS也可以满足。
把它看做图的话，就可以引出图的遍历。


2.贪心算法
基本思想：每步都选最优的解，最终得到最优解。
但这里需要解决一个关键问题：证明贪心策略得到的解是最终解，对自己来说，这个有点难度。
道理上觉的是对了，但严格证明会不知道该如何下手。
在一个解法中看到，算法导论中提到贪心算法的应用场景是：用动态规划有杀鸡用牛刀时选择贪心。
也让我理解了两种算法的关系，以前老搞不清楚如何选择。

[122]买卖股票的最佳时机 II
用折线图很容易看出贪心算法得到的解是最终解，但要证明就比较难了。

[45]跳跃游戏 II
从目标位置，逆向往回推导，每步按最优解处理，比较好理解。
只是每步的最优解依然需要从前往后查找。第一个找到的可达点就是最优解。


3.二分查找
要满足3个条件才能用：单独区间，有上下界，能够通过索引访问。面试时要注意。

[33]搜索旋转排序数组
都涉及到了半排序数组，因为涉及到两个有序数组，其实还是容易想到用二分查找法的。
关键点：mid分两半后，如何判断哪一半是有序的，
nums[left]<nums[mid]说明是有序的。
	如果targe在有序的一半，right=mid-1，在左区间夹逼；否则说明在无序的右区间，left=mid+1；
否则，说明右边区间才是有序的
    如果targe在有序的一半，left=mid+1，在右区间夹逼；否则说明无序的左区间，right=mid-1;

[153]寻找旋转排序数组中的最小值
大的思路、框架和[33]基本一致，只是返回值不一样。
最小值就是连续区间的最左的值，自己没想出来。

[74]搜索二维矩阵
将二维矩阵的索引通过公式转化为一维数组，就变成一个标准的二分查找。
转换公式：row=i/n, col=i%n





